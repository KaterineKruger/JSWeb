// ESTUDO

----------> Booleanos

let isAtivo = false
console.log(isAtivo)

isAtivo = true
console.log(isAtivo)

isAtivo = 1
console.log(isAtivo) // Número
console.log(!isAtivo) // Negação do número, o que o torna valor binário (boolean)
console.log(!!isAtivo) // Negação da negação

console.log('Os verdadeiros...')
console.log(!!3) // Número inteiro
console.log(!!-1) // Número inteiro
console.log(!!' ') // Espaço em texto
console.log(!!'texto') // Texto
console.log(!![]) // Array (mesmo vazio)
console.log(!!{}) // Objeto literal
console.log(!!Infinity) // Tipo infinito
console.log(!!(isAtivo = true)) // Atribuição verdadeira

console.log('Os falsos...')
console.log(!!0) // Zero
console.log(!!'') // String vazia
console.log(!!null) // Nulo
console.log(!!NaN) // Not a Number
console.log(!!undefined) // Indefinido
console.log(!!(isAtivo = false)) // Atribuição falsa

console.log('Para finalizar...')
console.log(!!('' || null || 0 || ' '))

let nome01 = ''
console.log(nome01 || 'Desconhecido')

let nome02 = 'Guilherme'
console.log(nome02 || 'Desconhecido')

----------> Operadores Relacionais

console.log('01)', '1' == 1)
console.log('02)', '1' === 1)
console.log('03)', '1' != 1)
console.log('04)', '1' !== 1)
console.log('05)', 3 < 1)
console.log('06)', 3 > 1)
console.log('07)', 3 <= 1)
console.log('08)', 3 >= 1)

const d01 = new Date(0)
const d02 = new Date(0)
console.log('09)', d01 == d02)
console.log('010)', d01 === d02)
console.log('011)', d01.getTime() === d02.getTime())
console.log('012)', undefined == null)
console.log('013)', undefined === null)

----------> Operadores Lógicos

function compras(trabalho01, trabalho02) {
    const comprarSorvete = trabalho01 || trabalho02
    const comprarTv50 = trabalho01 && trabalho02
    // const comprarTv32 = !!(trabalho01 ^ trabalho02) // Bitwise xor
    const comprarTv32 = trabalho01 != trabalho02
    const manterSaudavel = !comprarSorvete

    return { comprarSorvete, comprarTv50, comprarTv32, manterSaudavel }
}

console.log(compras(true, true))
console.log(compras(true, false))
console.log(compras(false, true))
console.log(compras(false, false))

----------> While

function getInteiroAleatorio(min, max) {
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor)
}

let opcao = 0

-- doWhile

do {
    opcao = getInteiroAleatorio(-1, 10)
    console.log(`Opção escolhida foi ${opcao}.`)
} while (opcao != -1)

console.log('Até a próxima!')

-- While

while (opcao != -1) {
    opcao = getInteiroAleatorio(-1, 10)
    console.log(`Opção escolhida foi ${opcao}.`)
}

console.log('Até a próxima!')

----------> if

Number.prototype.entre = function (inicio, fim) {
    return this >= inicio && this <= fim
}

const imprimirResultado = function (nota) {
    if (nota.entre(9, 10)) {
        console.log('Quadro de Honra')
    } else if (nota.entre(7, 8.99)) {
        console.log('Aprovado')
    } else if (nota.entre(4, 6.99)) {
        console.log('Recuperação')
    } else if (nota.entre(0, 3.99)) {
        console.log('Reprovado')
    } else {
        console.log('Nota inválida')
    }
}

imprimirResultado(10)
imprimirResultado(7.5)

----------> Switch

const imprimirResultado = function (nota) {
    switch (Math.floor(nota)) {
        case 10:
        case 9:
            console.log('Quadro de Honra')
            break
        case 8: case 7:
            console.log('Aprovado')
            break
        case 6: case 5: case 4:
            console.log('Recuperação')
            break
        case 3: case 2: case 1: case 0:
            console.log('Reprovado')
            break
        default:
            console.log('Nota inválida')
    }
}

imprimirResultado(10)
imprimirResultado(7.5)

----------> Function

let dobro = function (a) {
    return 2 * a
}

let ola = function () {
    return 'Olá'
}

// Função normal aponta para o global
let comparaComThis = function (param) {
    console.log(this === param)
}

comparaComThis(global)

const obj = {}
comparaComThis = comparaComThis.bind(obj)
comparaComThis(global)
comparaComThis(obj)

/* Closure é o escopo criado quando uma função é declarada.
Esse Escopo permite à função acessar e manipular variáveis externas à função.*/

----------> ArrowFunction

dobro = a => 2 * a   // Return implícito
console.log(dobro(Math.PI))

ola = () => 'Olá'
console.log(ola())

// Função Arrow não aponta para o global
let comparaComThisArrow = param => console.log(this === param)
comparaComThisArrow(global)
comparaComThisArrow(module.exports)

comparaComThisArrow = comparaComThisArrow.bind(obj)
comparaComThisArrow(obj)
comparaComThisArrow(module.exports)

----------> Função Construtora

function Carro(velocidadeMax = 200, delta = 5) {   // Delta é a aceleração do carro (acelera de 5 em 5)
    // Atributo privado
    let velocidadeAtual = 0

    // Método público
    this.acelerar = function () {
        if (velocidadeAtual + delta <= velocidadeMax) {
            velocidadeAtual += delta
        } else {
            velocidadeAtual = velocidadeMax
        }
    }

    // Método público
    this.getVelocidadeAtual = function () {
        return velocidadeAtual
    }
}

const uno = new Carro
uno.acelerar()
console.log(uno.getVelocidadeAtual())

const ferrari = new Carro(350, 20)
ferrari.acelerar()
ferrari.acelerar()
console.log(ferrari.getVelocidadeAtual())

----------> Função Factory

// Função Factory existe para evitar este tipo de repetição:
const prod01 = {
    nome: 'Livro 01',
    preco: 25
}

const prod02 = {
    nome: 'Camisa Polo',
    preco: 50
}

const prod03 = {
    nome: 'Capinha iPhone',
    preco: 100
}

// Função Factory simples:
function criarPessoa() {
    return {
        nome: 'Katerine',
        sobrenome: 'Krüger'
    }
}

console.log(criarPessoa())

----------> Bind
// *Bind* é o método responsável por "amarrar" um determinado objeto ao *this*

const pessoa = {
    saudacao: 'Bom dia!',
    falar() {
        console.log(this.saudacao)
    }
}

pessoa.falar()
const falar = pessoa.falar
falar() // Conflito entre paradigmas: funcional e OO

const falarDePessoa = pessoa.falar.bind(pessoa)
falarDePessoa()

----------> Parâmetro Padrão

// Estratégia 01 para gerar valor padrão

function soma01(a, b, c) {
    a = a || 1
    b = b || 1
    c = c || 1
    return a + b + c
}

console.log(soma01())
console.log(soma01(3))
console.log(soma01(1, 2, 3))
console.log(soma01(0, 0, 0)) // Zero retorna falso, assumindo assim o valor *1*   !!!BUG!!!

// Estratégia 02, 03 e 04 para gerar valor padrão

function soma02(a, b, c) {
    a = a !== undefined ? a : 1   // Segunda
    b = 1 in arguments ? b : 1    // Terceira
    c = isNaN(c) ? 1 : c          // Quarta - mais segura
    return a + b + c
}

console.log(soma02())
console.log(soma02(3))
console.log(soma02(1, 2, 3))
console.log(soma02(0, 0, 0))

// Estratégia de valor padrão ES2015

function soma03(a = 1, b = 1, c = 1) {
    return a + b + c
}

console.log(soma03())
console.log(soma03(3))
console.log(soma03(1, 2, 3))
console.log(soma03(0, 0, 0))

----------> IIFE

// IIFE -> Immediately Invoked Function Expression

(function() {
    console.log('Será executado na hora.')
    console.log('Foge do escopo mais abrangente (global).')
})()

// Usando escopo global:
console.log('Será executado na hora.')
console.log('Foge do escopo mais abrangente (global).')


----------> Call / Apply

function getPreco(imposto = 0, moeda = 'R$') {
    return `${moeda} ${this.preco * (1 - this.desc) * (1 + imposto)}`
}

const produto = {
    nome: 'Notebook',
    preco: 4500,
    desc: 0.15,
    getPreco
}

globalThis.preco = 20
globalThis.desc = 0.1
console.log(getPreco())                       // Chamada direta de Função
console.log(produto.getPreco())               // Chamada de Função pelo objeto

const carro = { preco: 49990, desc: 0.20 }

console.log(getPreco.call(carro))             // Chamada de Função por call
console.log(getPreco.apply(carro))            // Chamada de Função por apply

console.log(getPreco.call(carro, 0.17, '$'))
console.log(getPreco.apply(carro, [0.17, '$']))